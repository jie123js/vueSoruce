{"version":3,"file":"reactivity.esm-bundler.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts"],"sourcesContent":["export const isObject = (val) => typeof val == 'object' && val !== null;\nexport const isNumber = (val) => typeof val == 'number';\nexport const isFunction = (val) => typeof val == 'function'\nexport const isString = (val) => typeof val == 'string'\nexport const isBoolean = (val) =>  typeof val == 'boolean';\nexport const isArray =  Array.isArray;\nexport const extend = Object.assign;\n\n\n// 判断属性是不是原型属性 \nexport const hasOwn = (target,key) => Object.prototype.hasOwnProperty.call(target,key);\nexport const hasChanged = (oldValue,value) => oldValue !== value\n\nexport const isInteger = (key) => parseInt(key) + '' === key; // '3'  arr.xxx\n\n\n\nexport const enum ShapeFlags {\n    ELEMENT = 1, // 1元素\n    FUNCTIONAL_COMPONENT = 1 << 1, // 函数式组件 2 \n    STATEFUL_COMPONENT = 1 << 2, // 带状态的组件 4 \n    TEXT_CHILDREN = 1 << 3, // 内容是文本还 8 \n    ARRAY_CHILDREN = 1 << 4, // 内容是数组孩子 16\n    SLOTS_CHILDREN = 1 << 5,\n    TELEPORT = 1 << 6,\n    SUSPENSE = 1 << 7,\n    COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,\n    COMPONENT_KEPT_ALIVE = 1 << 9,\n    COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT\n  }\n  \n\n  // +=   LET XXX = A+B\n  // |=   LET XXX = A | B","export function effect(fn, option: any = {}) {\n  //fn默认是不具备数据变化更新视图的功能\n  let effect = createReactiveEffect(fn, option); //把fn包裹成一个响应式的函数\n  if (!option.lazy) {\n    effect();\n  }\n  return effect;\n}\n\nlet uid = 0;\nlet activeEffect;\nfunction createReactiveEffect(fn, option) {\n  const effect = function () {\n    //需要把effect暴露出去\n    activeEffect = effect; //类似以前vue2的 Dep.target = watcher\n    fn();\n    activeEffect = null;\n  };\n  effect.id = uid++;\n  effect._isEffect = true;\n  effect.raw = fn;\n  effect.deps = [];\n  effect.options = option;\n  return effect;\n}\n\nconst targetMap = new WeakMap(); //为什么里面不用weakmap因为weakmap的key必须是对象\nexport function track(target, type, key) {\n  //创建一个{obj:(name:[effect.effect])}  建是对象,值是一个map,map里面值是一个set\n  if (!activeEffect) {\n    //不在effet里面的不进行依赖收集\n    return;\n  }\n  console.log(111);\n\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    targetMap.set(target, (depsMap = new Map()));\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    depsMap.set(key, (dep = new Set()));\n  }\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect);\n  }\n  console.log(targetMap);\n}\nexport function trigger(target, key, value) {\n  let depsMap = targetMap.get(target);\n  if (!depsMap) return;\n  const effects = depsMap.get(key);\n  effects.forEach((effect) => effect());\n}\n","import { extend, isObject } from \"@vue/shared\";\nimport { track, trigger } from \"./effect\";\nimport { reactive, readonly } from \"./reactive\";\n\nconst get = createGetter();\nconst readonlyGet = createGetter(true);\nconst shallowGet = createGetter(false, true);\nconst shallowReadonlyGet = createGetter(true, true);\n\nconst set = createSetter();\n\nconst readonlySet = {\n  set(target, key) {\n    console.warn(`cannot set on ${key},readonly`);\n  },\n};\nfunction createSetter() {\n  return function set(target, key, value, reactiver) {\n    //value是设置值,其他是一样的\n    //Reflect.xxx都会有布尔值的返回值\n    let res = Reflect.set(target, key, value, reactiver); //等价于 target[key]=value\n    console.log(\"设置值\", key, value);\n    //触发更新逻辑\n    trigger(target, key, value);\n    return res; //本来这个语法就是要返回一个true的  然后Reflect.xxx都会有布尔值的返回值\n  };\n}\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target, key, reactiver) {\n    let res = Reflect.get(target, key, reactiver); //todo 这2个写法等价 target[key]\n    //procy一般和reflect联合使用\n    if (!isReadonly) {\n      //如果对象是一个仅读的属性,那么意味着对象不可能被更改,也就不会更新试图,不需要增添依赖收集\n      //不是仅读的才去收集依赖\n      track(target, \"get\", key);\n    }\n    console.log(target[key]);\n\n    if (shallow) {\n      //如果是浅代理就不用递归了\n      return res;\n    }\n    //这个就是 取值了才会去递归 不会一上来就把对象里面包对象的值全部递归,这就是vue3比2好的一些地方\n\n    //  return isReadonly ? readonly(res) : reactive(res); //懒代理,只有取值的时候才会去代理\n\n    //!下面这样写会好理解一点,但是没必要,因为前面已经判断过是不是对象了\n    if (isObject(res)) {\n      //如果是对象就递归代理,但是不是一开始就代理,是用到了再代理\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n\n    return res;\n  };\n}\n\nexport const mutableHandlers = {\n  get: get,\n  set,\n};\n\nexport const shallowReactiveHandlers = {\n  get: shallowGet,\n  set,\n};\n\nexport const readonlyHandlers = extend(\n  {\n    get: readonlyGet,\n  },\n  readonlySet\n);\n\nexport const shallowReadonlyHandlers = extend(\n  {\n    get: shallowReadonlyGet,\n  },\n  readonlySet\n);\n","import { isObject } from \"@vue/shared\";\nimport {\n  mutableHandlers,\n  readonlyHandlers,\n  shallowReactiveHandlers,\n  shallowReadonlyHandlers,\n} from \"./baseHandlers\";\n//const reactiveMap = {}  如果等于对象  对象的key不能是对象\nconst reactiveMap = new WeakMap(); //弱引用 map的key是可以用对象的 做缓存\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\nexport function reactive(target: object) {\n  //mutableHandlers\n  return createReactiveObject(target, mutableHandlers, reactiveMap);\n}\n\nexport function shallowReactive(target: object) {\n  //shallowReactiveHandlers\n  return createReactiveObject(\n    target,\n    shallowReactiveHandlers,\n    shallowReactiveMap\n  );\n}\n\nexport function readonly(target: object) {\n  //readonlyHandlers\n  return createReactiveObject(target, readonlyHandlers, readonlyMap);\n}\n\nexport function shallowReadonly(target: object) {\n  //shallowReadonlyHandlers\n  return createReactiveObject(\n    target,\n    shallowReadonlyHandlers,\n    shallowReadonlyMap\n  );\n}\n\nexport function createReactiveObject(target, baseHandlers, proxyMap) {\n  if (!isObject(target)) {\n    return target;\n  }\n  //const proxyMap = isReadonly ? readonlyMap : reactiveMap;\n  const existsProxy = proxyMap.get(target);\n  if (existsProxy) {\n    return existsProxy;\n  }\n  //创建代理对象 ,reactive(reactive({})) 做缓存 不要重复代理\n  const proxy = new Proxy(target, baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n"],"names":[],"mappings":"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"}