
// 基本的概念 计算机分配任务的最小单位是什么？ 进程是最小单位 每一个应用程序都是一个进程

// 浏览器是一个多进程模型 （每个页卡都是一个独立的进程，如果其中一个挂了是不会导致整个浏览器挂掉的）

// 浏览器中进程的组成：  
// 主进程（负责创建和销毁）  
// 渲染进程（每个页卡都有一个 *） 
// 网络进程 发送http请求  
// 插件（独立的进程）  
// gpu绘图进程


// 渲染进程 (线程)
// ui渲染 gui渲染线程 渲染页面、布局、画页面
// js引擎线程 执行js代码的  js单独的线程（主线程是单线程的）  互斥的？ 如果js是多线程的会有什么问题？

// 在js中的执行过程中还会创建一些其他的线程  定时器、http请求、事件
// 我们在js引擎线程上正在执行代码 可能定时器到时间了，用户点击按钮了。  我们要规划执行的顺序 事件环就是用来规定怎么调度执行的

// 无线循环的线程（事件触发线程） 目的就是为了调度任务的


// 都是异步的
// 宏任务： <script>, ui渲染也是宏任务,定时器,http请求，事件（用户操作click，mousemove），MessageChannel,setImmediate(ie下有的)
// 微任务： 原生的promise,mutationObserver,node中的（process.nextTick）queueMicrotask

// 异步方法：requestFrameAnimation  requestIDleCallback （这两个方法是根渲染相关的，不算事件环的异步分） 也有人把他们规划成了红热舞

// 默认是先要执行一个script脚本的（微任务先执行，这个说法不对），因为script是一个宏任务
// 在代码执行的时候会调用对应的setTimeout，ajax，事件 调用webApi的时候，例如定时器，时间到达后会将回调放到队列中  (消息队列)
// 宏任务队列只有一个，微任务队列每次执行宏任务的时候会将微任务的方法放到队列中 (创建一个新队列)


// 主栈代码执行完毕后，会查找所有的微任务将其执行并且清空， 如果微任务嵌套会将生成的新的微任务放到本次队列的后面
// 微任务执行完毕后，要检测"是否需要"渲染, 浏览器有自己的刷新频率。 渲染是在宏任务之前做的
// 在去宏任务队列中取出一个宏任务执行此流程

// 如果宏任务队列空了，事件触发线程就会进入到休眠状态等待宏任务中有新任务， 按照流程继续执行

// 执行代码完毕后，会清空微任务(执行多个)，宏任务每次只执行（一个）